import{_ as o,c as e,o as c,e as t}from"./app.4ea82cce.js";const k=JSON.parse('{"title":"Topics","description":"","frontmatter":{"layout":"doc"},"headers":[],"relativePath":"knowledge-deposition/RabbitMQ/Topics.md"}'),d={name:"knowledge-deposition/RabbitMQ/Topics.md"},i=t('<h1 id="topics" tabindex="-1">Topics <a class="header-anchor" href="#topics" aria-hidden="true">#</a></h1><blockquote><p>之前的代码中，使用<code>Direct</code>交换机精准处理某个类型的日志</p></blockquote><blockquote><p>现在在扩展一下这个功能，比如之前通过日志等级来决定是否处理，现在再加一个条件，某个消费者只处理从<code>某个地方(比如bin)</code>发出的<code>info级别</code>的日志，这里面要匹配两个条件，一是<code>日志的发生地点为bin</code>，而且<code>日志级别要是info</code></p></blockquote><blockquote><p>要符合上面要求的话，使用<code>Direct</code>交换机就实现不不了了，那么就要使用<code>Topic</code>交换机来实现</p></blockquote><blockquote><p><code>Topic</code>交换机背后的逻辑类似于<code>Direct</code>交换机，通过<code>routing key</code>来匹配要将消息发送给哪个队列，匹配时有两种特殊情况：</p></blockquote><ul><li><p><code>*</code>：正好能够<code>匹配一个单词</code></p></li><li><p><code>#</code>：可以匹配<code>0个或多个单词</code></p></li></ul>',6),p=[i];function a(s,n,r,_,l,u){return c(),e("div",null,p)}const T=o(d,[["render",a]]);export{k as __pageData,T as default};
