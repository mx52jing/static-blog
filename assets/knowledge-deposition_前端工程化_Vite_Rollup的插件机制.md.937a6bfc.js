import{_ as o,c as e,o as l,e as c}from"./app.c8804d0c.js";const s="/static-blog/image/Vite/rollup-plugin/1.png",a="/static-blog/image/Vite/rollup-plugin/2.png",D=JSON.parse('{"title":"Rollup的插件机制","description":"","frontmatter":{"layout":"doc"},"headers":[{"level":2,"title":"Rollup 整体构建阶段","slug":"rollup-整体构建阶段","link":"#rollup-整体构建阶段","children":[]},{"level":2,"title":"插件Hook分类","slug":"插件hook分类","link":"#插件hook分类","children":[{"level":3,"title":"根据构建阶段分类","slug":"根据构建阶段分类","link":"#根据构建阶段分类","children":[]},{"level":3,"title":"根据Hook的执行方式分类","slug":"根据hook的执行方式分类","link":"#根据hook的执行方式分类","children":[]},{"level":3,"title":"拓展","slug":"拓展","link":"#拓展","children":[]}]},{"level":2,"title":"插件工作流","slug":"插件工作流","link":"#插件工作流","children":[{"level":3,"title":"Build阶段工作流","slug":"build阶段工作流","link":"#build阶段工作流","children":[]},{"level":3,"title":"Output阶段工作流","slug":"output阶段工作流","link":"#output阶段工作流","children":[]}]}],"relativePath":"knowledge-deposition/前端工程化/Vite/Rollup的插件机制.md"}'),t={name:"knowledge-deposition/前端工程化/Vite/Rollup的插件机制.md"},d=c(`<h1 id="rollup的插件机制" tabindex="-1">Rollup的插件机制 <a class="header-anchor" href="#rollup的插件机制" aria-hidden="true">#</a></h1><p>类似于Vue、React，在Rollup中也有一套自己的生命周期，从打包开始到产物输出，在每个周期都会执行特有的<code>钩子函数(Hook)</code>。</p><h2 id="rollup-整体构建阶段" tabindex="-1">Rollup 整体构建阶段 <a class="header-anchor" href="#rollup-整体构建阶段" aria-hidden="true">#</a></h2><p>Rollup主要经历了<code>Build</code>和<code>Output</code>两个阶段</p><p>对于一次完整的构建过程而言，<code>Rollup</code>会先进入到<code>Build</code>阶段，解析各模块的<code>内容</code>及<code>依赖关系</code>，然后进入<code>Output</code>阶段，完成打包及输出。在不同的阶段，插件会有不同的工作流程。</p><h2 id="插件hook分类" tabindex="-1">插件Hook分类 <a class="header-anchor" href="#插件hook分类" aria-hidden="true">#</a></h2><h3 id="根据构建阶段分类" tabindex="-1">根据构建阶段分类 <a class="header-anchor" href="#根据构建阶段分类" aria-hidden="true">#</a></h3><p>Rollup的主要构建有<code>Build</code>和<code>Output</code>两大阶段，根据<code>构建阶段</code>分类，插件的<code>Hook</code>也可分为<code>Build Hook</code>和<code>Output Hook</code></p><ul><li><p><code>Build Hook</code>就是在<code>Build</code>阶段执行的钩子函数，在这个阶段主要进行<code>模块代码的转换</code>、<code>AST解析</code>以及<code>模块依赖的解析</code>，那么这个阶段的Hook对于代码的操作粒度一般为<code>模块</code>级别，也就是单文件级别</p></li><li><p><code>Output Hook</code>主要进行代码的打包，操作粒度一般为<code>chunk</code>级别(一个chunk通常指<code>很多文件打包到一起的产物</code>)。</p></li></ul><h3 id="根据hook的执行方式分类" tabindex="-1">根据Hook的执行方式分类 <a class="header-anchor" href="#根据hook的执行方式分类" aria-hidden="true">#</a></h3><p>根据Hook的执行方式可以分为<code>Async</code>、<code>Sync</code>、<code>Parallel</code>、<code>Sequential</code>、<code>First</code>这几类</p><h4 id="async-sync" tabindex="-1"><strong>Async &amp; Sync</strong> <a class="header-anchor" href="#async-sync" aria-hidden="true">#</a></h4><p>Async和Sync钩子函数分别代表<code>异步</code>和<code>同步</code>的钩子函数，Async钩子需要返回一个Promise，否则该钩子会被认为是Sync同步钩子</p><h4 id="first" tabindex="-1"><strong>First</strong> <a class="header-anchor" href="#first" aria-hidden="true">#</a></h4><p>如果多个插件都实现了该类型的Hook，那Hook将按顺序执行，直到其中一个Hook返回<code>非null</code>或者<code>非undefined</code>的值。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>比如<code>resolveId</code>这个Hook，如果多个插件都实现了这个hook，其中某个插件的<code>resolveId</code>函数返回了一个路径，将停止执行后续插件的<code>resolveId</code>方法</li></ul></div><h4 id="sequential" tabindex="-1"><strong>Sequential</strong> <a class="header-anchor" href="#sequential" aria-hidden="true">#</a></h4><ul><li><p>如果好几个插件实现了该Hook，它们将会按照指定的顺序执行，如果当前Hook是<code>异步</code>的，后续的Hook也要等待当前Hook的状态为resolved后才能执行</p></li><li><p>这种类型的Hook也适用于当前插件的Hook依赖上一插件Hook的处理结果，要等上一个插件Hook处理完后才返回处理结果给当前插件的Hook。比如<code>transform</code>钩子函数</p></li></ul><h4 id="parallel" tabindex="-1"><strong>Parallel</strong> <a class="header-anchor" href="#parallel" aria-hidden="true">#</a></h4><ul><li>该类型的Hook是指可以并行执行的Hook，如果<code>多个插件</code>都实现了该类型的钩子函数，那么这些钩子函数可以同时执行。就算当前Hook是异步的，其他该类型的Hook也不会等待该Hook执行完毕，而是一起执行</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>比如在<code>Build</code>阶段的<code>buildStart</code>钩子，它的执行时机是在<code>构建刚开始</code>的时候，每个插件声明的<code>buildStart</code>函数可以做一些状态初始化操作，但这些插件之间的操作并不是相互依赖，是可以并发执行的，从而提升构建性能。反之，对于需要<code>依赖其他插件处理结果</code>的情况就不适合用<code>Parallel</code>钩子了，比如<code>transform</code>钩子函数。</p></div><h3 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-hidden="true">#</a></h3><p>Hook可以是一个函数，也可以是一个对象，如果是一个对象，则对象中必须要有一个<code>handler</code>函数，该函数其实相当于实际的Hook，使用对象时，可以在对象中添加一些可选项，如下：</p><ul><li>order: <code>&quot;pre&quot; | &quot;post&quot; | null</code></li></ul><p>如果有多个Hook，可以通过<code>order</code>选项来设置Hook执行优先级，<code>pre</code>先执行，<code>post</code>后执行，如果不设置或者设置为<code>null</code>，将会在用户指定的位置执行</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">resolveFirst</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">		name</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">resolve-first</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">		resolveId</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">			order</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">pre</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">			handler</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">source</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">source</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">external</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">					</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> id</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">source</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> external</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">				</span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">			</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">		</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">	</span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>sequential: <code>boolean</code></li></ul><p><strong>该选项只能用于<code>Parallel(并行钩子)</code>类型的Hook</strong></p><p>当某个Hook使用该选项后，此Hook将会等待前面所有插件的该Hook函数都并行执行完毕后，再执行该Hook函数，然后在并行执行剩余插件的该Hook</p><blockquote><p>例如： 有5个插件A，B，C，D，E，都实现了相同的Parallel Hook，其中C插件中设置了<code>sequential: true</code>，那么Rollup将会先并发执行<code>A，B</code>插件的该Hook，然后执行<code>C</code>插件的该Hook，当<code>C</code>执行完毕后，再并发执行<code>D，E</code>插件的该Hook</p></blockquote><h2 id="插件工作流" tabindex="-1">插件工作流 <a class="header-anchor" href="#插件工作流" aria-hidden="true">#</a></h2><hr><h3 id="build阶段工作流" tabindex="-1">Build阶段工作流 <a class="header-anchor" href="#build阶段工作流" aria-hidden="true">#</a></h3><p>在Build阶段会执行相关的<a href="https://rollupjs.org/plugin-development/#build-hooks" target="_blank" rel="noreferrer">Build Hooks</a>，是由<code>rollup.rollup(inputOptions)</code>函数触发，构建阶段的第一个Hook是<a href="https://rollupjs.org/plugin-development/#options" target="_blank" rel="noreferrer">options</a>，最后一个Hook是<a href="https://rollupjs.org/plugin-development/#buildend" target="_blank" rel="noreferrer">buildEnd</a>，当构建过程出错时，会执行<a href="https://rollupjs.org/plugin-development/#closebundle" target="_blank" rel="noreferrer">closeBundle</a></p><blockquote><p>Build流程如下图：</p></blockquote><p><img src="`+s+'" alt=""></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在<code>watch</code>模式下，Rollup内部会初始化一个<code>watcher</code>对象，当文件内容发生变化时，watcher对象会同时触发<a href="https://rollupjs.org/plugin-development/#watchchange" target="_blank" rel="noreferrer">watchChange Hook</a>，对项目进行重新构建。此外，在打包结束时，Rollup会自动清除<code>watcher</code>对象，并调用<a href="https://rollupjs.org/plugin-development/#closewatcher" target="_blank" rel="noreferrer">closeWatcher Hook</a></p></div><blockquote><p>Build阶段流程如下：</p></blockquote><ul><li><p>执行<code>options</code> Hook，<code>替换</code>或<code>操作</code>传递给<code>rollup.rollup</code>的配置项</p></li><li><p>调用<code>buildStart</code> Hook，正式开始构建流程，<strong>如果只是查看配置项，推荐使用<a href="https://rollupjs.org/plugin-development/#buildstart" target="_blank" rel="noreferrer">buildStart</a></strong></p></li><li><p>调用<code>resolveId</code> Hook，开始解析路径(从<a href="https://rollupjs.org/configuration-options/#input" target="_blank" rel="noreferrer">input</a>配置指定的入口文件开始解析)</p></li><li><p>调用<code>load</code> Hook，加载模块内容</p></li><li><p>调用<code>shouldTransformCachedModule</code> Hook，这个钩子可以用来找出缓存了哪些模块，并访问它们缓存的元信息。</p><ul><li><p>如果使用了Rollup缓存(例如<code>watch</code>模式下或通过<code>JavaScript API</code>显式地使用)，如果<code>load</code> Hook加载的代码与缓存副本中的相同则跳过<code>transform</code> Hook并使用模块缓存的代码，然后执行<code>moduleParsed</code> Hook</p></li><li><p>如果<code>shouldTransformCachedModule</code> Hook返回<code>true</code>，则从缓存中删除此模块并重新执行<code>transform</code> Hook</p></li></ul></li><li><p>调用<code>transform</code> Hook，对模块内容进行转换，例如<code>babel</code>转译</p></li><li><p>调用<code>moduleParsed</code> Hook（Rollup拿到最后的模块内容，进行<code>AST</code>分析，得到所有的<code>import</code>内容，然后执行此Hook），执行该Hook后有以下两种情况：</p><ul><li><p>如果是<code>普通的import</code>，则跳到<code>resolveId</code> Hook流程</p></li><li><p>如果是<code>动态import</code>，则执行<code>resolveDynamicImport</code> Hook解析路径，如果路径解析成功，就跳到<code>load</code> Hook流程，否则就跳到<code>resolveId</code> Hook流程</p></li></ul></li><li><p>直到所有的<code>import</code>都解析完毕，Rollup会执行<code>buildEnd</code> Hook，Build阶段结束</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Rollup在解析路径的时候，即执行<code>resolveId</code>/<code>resolveDynamicImport</code> Hook的时候，如果该路径被标记为<code>external</code>(外部模块)，表明该路径内容不用进行Rollup打包，则直接跳转到<code>buildEnd</code> Hook，不再执行<code>load</code>/<code>transform</code>/<code>resolveId</code>等Hook</p></div><h3 id="output阶段工作流" tabindex="-1">Output阶段工作流 <a class="header-anchor" href="#output阶段工作流" aria-hidden="true">#</a></h3><p><a href="https://rollupjs.org/plugin-development/#output-generation-hooks" target="_blank" rel="noreferrer">Output generation hooks</a>可以提供关于生成的<code>bundle</code>的信息并在生成完成后修改构建。它们的工作方式和类型与<code>Build Hook</code>相同，但是每次调用<code>bundle.generate(outputOptions)</code>或<code>bundle.write(outputOptions)</code>时会单独调用，只会调用其中一个</p><blockquote><p>Output流程如下图：</p></blockquote><p><img src="'+a+'" alt=""></p><blockquote><p>Output阶段流程如下：</p></blockquote><ul><li><p>执行所有插件的<code>outputoptions</code> Hook，对<a href="https://rollupjs.org/configuration-options/#output-dir" target="_blank" rel="noreferrer">output配置</a>进行转换</p></li><li><p>并发执行<code>renderStart</code> Hook，正式开始打包</p></li><li><p>从入口模块开始扫描，针对<code>动态import</code>语句执行<code>renderDynamicImport</code>钩子，来自定义动态import的内容</p></li><li><p>判断是否遇到<code>i<wbr>mport.meta</code>语句</p><ul><li><p>如果没有遇到<code>i<wbr>mport.meta</code>语句，则并发执行所有插件的<code>banner</code>、<code>footer</code>、<code>intro</code>、<code>outro</code> Hook，向打包产物的固定位置(比如头部和尾部)插入一些<code>自定义的内容</code>，比如协议声明内容、项目介绍等等</p></li><li><p>如果遇到<code>i<wbr>mport.meta</code>语句:</p><ul><li><p>对于<code>i<wbr>mport.meta.url</code>语句调用<code>resolveFileUrl</code>来自定义url解析逻辑</p></li><li><p>对于<code>其他i<wbr>mport.meta</code>属性，则调用<code>resolveImportMeta</code>来进行自定义的解析。</p></li></ul></li></ul></li><li><p>接下来Rollup会生成所有<code>chunk</code>的内容，针对每个chunk会依次调用插件的<code>renderChunk</code>方法进行自定义操作，在这里就可以直接操作打包产物了。</p></li><li><p>接着调用<code>augmentChunkHash</code> Hook，用于扩充单个chunks的hash值，如果该函数返回<code>false</code>将不会修改hash值</p></li><li><p>随后会调用<code>generateBundle</code> Hook，这个Hook的入参里面会包含所有的打包产物信息，包括<code>chunk(打包后的代码)</code>、<code>asset(最终的静态资源文件)</code>。我们可以在这里<code>删除一些chunk</code>或者<code>asset</code>，最终这些内容将不会作为产物输出。</p></li><li><p><code>rollup.rollup</code>方法会返回一个<code>bundle</code>对象，这个对象是包含<code>generate</code>和<code>write</code>两个方法</p><ul><li>如果输出是通过<code>bundle.generate(...)</code>方法成功生成的，那么最后一个Hook就是<code>generateBundle</code> Hook</li><li>如果输出是通过<code>bundle.write(...)</code>方法成功生成的，那么最后一个Hook就是<code>writeBundle</code> Hook</li><li>如果输出过程中出错，会触发<code>renderError</code> Hook，然后执行<code>closeBundle</code> Hook 结束打包</li></ul></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><ul><li>bundle.generate(...)和bundle.write(...)的区别是<code>write</code>方法会将代码写入到磁盘中，同时触发<code>writeBundle</code> Hook，而<code>generateBundle</code> Hook执行的时候，产物还并没有输出，</li><li>以上两个Hook的顺序为<code>generateBundle =&gt; 输出产物到磁盘 =&gt; writeBundle</code></li></ul></div>',47),n=[d];function p(r,i,u,h,k,F){return l(),e("div",null,n)}const H=o(t,[["render",p]]);export{D as __pageData,H as default};
