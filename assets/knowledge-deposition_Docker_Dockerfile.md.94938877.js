import{_ as s,c as l,o as e,a}from"./app.82b43899.js";const u=JSON.parse('{"title":"Dockerfile","description":"","frontmatter":{"layout":"doc"},"headers":[{"level":2,"title":"Dockerfile指令","slug":"dockerfile指令","link":"#dockerfile指令","children":[{"level":3,"title":"FROM","slug":"from","link":"#from","children":[]},{"level":3,"title":"RUN","slug":"run","link":"#run","children":[]},{"level":3,"title":"COPY","slug":"copy","link":"#copy","children":[]},{"level":3,"title":"ADD","slug":"add","link":"#add","children":[]},{"level":3,"title":"CMD","slug":"cmd","link":"#cmd","children":[]},{"level":3,"title":"ENTRYPOINT","slug":"entrypoint","link":"#entrypoint","children":[]},{"level":3,"title":"ENV","slug":"env","link":"#env","children":[]},{"level":3,"title":"EXPOSE","slug":"expose","link":"#expose","children":[]},{"level":3,"title":"WORKDIR","slug":"workdir","link":"#workdir","children":[]}]},{"level":2,"title":"build","slug":"build","link":"#build","children":[]}],"relativePath":"knowledge-deposition/Docker/Dockerfile.md"}'),o={name:"knowledge-deposition/Docker/Dockerfile.md"},n=a(`<h1 id="dockerfile" tabindex="-1">Dockerfile <a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a></h1><p><code>Dockerfile</code>是一个文本文件，其内包含了一条条的<code>指令(Instruction)</code>，<code>每一条指令构建一层</code>，因此每一条指令的内容，就是描述该层应当如何构建。</p><h2 id="dockerfile指令" tabindex="-1">Dockerfile指令 <a class="header-anchor" href="#dockerfile指令" aria-hidden="true">#</a></h2><h3 id="from" tabindex="-1">FROM <a class="header-anchor" href="#from" aria-hidden="true">#</a></h3><ul><li><code>FROM</code>指定基础镜像</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">FROM</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">basicImage</span></span>
<span class="line"></span></code></pre></div><ul><li><p>定制镜像都要以一个镜像为基础，<code>FROM</code>作用就是<code>指定基础镜像</code>。</p></li><li><p>在<code>Dockerfile</code>中，<code>FROM</code>是<code>必须</code>的，<code>必须是第一条指令</code>。</p></li></ul><p><strong><code>特殊空白镜像</code></strong></p><ul><li><p><code>Docker</code>存在一个特殊的<code>scratch</code>镜像。这个镜像是<code>虚拟的概念</code>，不实际存在，表示一个<code>空白的镜像</code>。</p></li><li><p>以<code>scratch</code>为基础镜像的，表示<code>不以任何镜像为基础</code>，所写的指令将作为<code>镜像第一层</code>开始存在。</p></li></ul><h3 id="run" tabindex="-1">RUN <a class="header-anchor" href="#run" aria-hidden="true">#</a></h3><ul><li><code>RUN</code>表示执行命令</li></ul><p>两种格式：</p><ul><li><code>shell</code>格式： RUN &lt;命令&gt;\`,如下：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">RUN</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">echo</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&lt;h1&gt;hello&lt;/h1&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">/usr/share/nginx/html/index.html</span></span>
<span class="line"></span></code></pre></div><ul><li><code>exec</code>格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code></li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><strong>注意：不要用下面这种写法</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">FROM basicImage</span></span>
<span class="line"><span style="color:#A6ACCD;">RUN operation1</span></span>
<span class="line"><span style="color:#A6ACCD;">RUN operation2</span></span>
<span class="line"><span style="color:#A6ACCD;">RUN operation3</span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></div><p>因为<code>Dockerfile</code>中<code>每一个指令都会建立一层镜像</code>，<code>RUN</code>也是，每一个<code>RUN</code>就新建立一层，在其上执行这些命令，执行结束后，<code>commit</code>这一层的修改，构成<code>新的镜像</code>，上面这种写法创建了<code>3层甚至更多镜像</code>，导致镜像层数过多，而我们并不需要这么多层，所以不提倡</p><blockquote><p>推荐写法：</p></blockquote><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">FROM basicImage</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">RUN  yum install -y gcc gcc-c++ make perl-devel \\</span></span>
<span class="line"><span style="color:#A6ACCD;">     &amp;&amp; mkdir -p /opt/app/ /opt/source/ \\</span></span>
<span class="line"><span style="color:#A6ACCD;">     &amp;&amp; cd /opt/source \\</span></span>
<span class="line"><span style="color:#A6ACCD;">     &amp;&amp; 其他操作</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>执行<code>RUN</code>命令的时候，会<code>重写hosts文件</code>，因此在<code>RUN</code>之前修改<code>hosts</code>文件是无效的</p></div><h3 id="copy" tabindex="-1">COPY <a class="header-anchor" href="#copy" aria-hidden="true">#</a></h3><ul><li><code>COPY</code>表示复制文件</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">COPY</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">源路径</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">目标路径</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">COPY</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">源路径1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">源路径2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">, ..., </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">目标路径</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><ul><li><p>和<code>RUN</code>指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用</p></li><li><p><code>COPY</code>指令是从<code>构建上下文</code>目录中的<code>源路径</code>的<code>文件或者目录</code>复制到<code>新一层的镜像内</code>的<code>目标路径</code>。</p></li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">COPY</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">./app</span></span>
<span class="line"></span></code></pre></div><ul><li>可以是<code>多个源路径</code>，也可以是<code>通配符</code>，只要匹配都会选中</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">COPY</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xxx*</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">, </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">aaa/</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/dir/</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><ul><li><p><code>目标路径</code>可以是<code>容器内的绝对路径</code>，也可以是<code>相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）</code>。目标路径<code>不需要事先创建</code>，如果<code>目录不存在</code>会在复制文件前<code>先行创建缺失目录</code>。</p></li><li><p>使用<code>COPY</code>指令，源文件的各种<code>元数据</code>都会保留。比如<code>读、写、执行权限、文件变更时间</code>等。</p></li></ul><h3 id="add" tabindex="-1">ADD <a class="header-anchor" href="#add" aria-hidden="true">#</a></h3><ul><li><p><code>ADD</code>：更高级的复制文件</p></li><li><p><code>ADD</code>和<code>COPY</code>格式以及性质基本一致，在<code>COPY</code>基础上加了一些功能。</p></li><li><p><code>ADD</code>指令会使<code>镜像构建缓存失效</code>，从而可能会令镜像构建变得比较缓慢</p></li><li><p><code>ADD</code>具有<code>自动解压缩</code>功能，如果需要自动解压缩功能就使用<code>ADD</code>，否则如果只是<code>单纯复制文件</code>，<code>COPY</code>将是更好的选择。</p></li></ul><h3 id="cmd" tabindex="-1">CMD <a class="header-anchor" href="#cmd" aria-hidden="true">#</a></h3><ul><li><code>CMD</code> 容器启动命令</li></ul><p><code>CMD</code>和<code>RUN</code>相似，也是两种格式</p><ul><li>shell格式：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">CMD</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#C3E88D;">comman</span><span style="color:#A6ACCD;">d</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><ul><li>exec格式：</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">CMD</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">可执行文件</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">参数1</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">参数2</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">...</span><span style="color:#89DDFF;">]</span></span>
<span class="line"></span></code></pre></div><p>使用<code>shell</code>命令，会被包装为<code>sh -c</code>的参数形式进行执行。</p><p>例如：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">CMD</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">echo</span><span style="color:#A6ACCD;"> $HOME</span></span>
<span class="line"></span></code></pre></div><p>实际执行中会变为：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">CMD</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">sh</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">-c</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">,</span><span style="color:#89DDFF;"> &quot;</span><span style="color:#C3E88D;">echo </span><span style="color:#A6ACCD;">$HOME</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;"># 一定要用双引号</span></span>
<span class="line"></span></code></pre></div><h3 id="entrypoint" tabindex="-1">ENTRYPOINT <a class="header-anchor" href="#entrypoint" aria-hidden="true">#</a></h3><ul><li><p><code>ENTRYPOINT</code>和<code>CMD</code>一样，都是配置容器<code>启动后执行的命令</code>，<code>ENTRYPOINT</code>可以在<code>docker run</code>的时候通过<code>--ectrypoint</code>传入。</p></li><li><p><code>ENTRYPOINT</code>和<code>RUN</code>相似，也是两种格式 <code>exec</code>格式和 <code>shell</code>格式</p></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当指定了<code>ENTRYPOINT</code>后，<code>CMD</code>的含义就发生了改变，不再是直接的运行其命令，而是将<code>CMD的内容作为参数</code>传给<code>ENTRYPOINT</code>指令。</p></div><p>例如：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">FROM centos</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">RUN  yum install ...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">ENTRYPOINT [&quot;xxx.sh&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">CMD [&quot;aaa&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>如上，<code>aaa</code>就会作为参数传到执行的<code>xxx.sh</code>内</p><p>或者是</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">FROM centos</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">RUN  yum install ...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">...</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">ENTRYPOINT [&quot;xxx.sh&quot;]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>比如将这个修改<code>build</code>成<code>demo:v1</code>版本：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-t</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">demo:v1</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span></span>
<span class="line"></span></code></pre></div><p>然后在命令行执行</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">run</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--name</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">demo_server</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">demo:v1</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">CMD</span></span>
<span class="line"></span></code></pre></div><p>此时的<code>CMD</code>也会作为参数传递给<code>ENTRYPOINT</code>运行的命令</p><h3 id="env" tabindex="-1">ENV <a class="header-anchor" href="#env" aria-hidden="true">#</a></h3><ul><li><p><code>ENV</code>设置环境变量</p></li><li><p>指定一个<code>环境变量</code>，会被后续<code>RUN</code>指令使用，可以在<code>容器内被脚本或者程序</code>调用</p></li></ul><p>有两种格式</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">ENV</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">key</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">value</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#或者</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">ENV</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">key1=value1</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">key2=value2</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">...</span></span>
<span class="line"></span></code></pre></div><blockquote><p>示例</p></blockquote><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"><span style="color:#FFCB6B;">ENV</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">VERSION</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2.2</span></span>
<span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">#或者</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"><span style="color:#FFCB6B;">ENV</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">VERSION=</span><span style="color:#F78C6C;">2.2</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">MY_ENV=hello</span></span>
<span class="line"><span style="color:#82AAFF;">...</span></span>
<span class="line"></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>如果设置的<code>环境变量</code>中间有<code>空格</code>，那么环境变量记得用<code>双引号(&quot;&quot;)</code>包裹</strong></p><p>例如：</p><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">ENV</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">XXX</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Hello World</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre></div></div><h3 id="expose" tabindex="-1">EXPOSE <a class="header-anchor" href="#expose" aria-hidden="true">#</a></h3><ul><li><code>EXPOSE</code>暴露端口</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">EXPOSE</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">7100</span></span>
<span class="line"></span></code></pre></div><ul><li><p><code>EXPOSE</code>声明容器<code>运行时</code>提供的<code>服务端口</code>，只是一个声明，不会因为这个声明就开启这个端口的服务。</p></li><li><p><code>EXPOSE</code>和<code>docker run -p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区别：</p><ul><li><p><code>docker run -p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>：映射<code>宿主端口</code>和<code>容器端口</code>，就是将容器的对应端口服务<code>公开给外界访问</code></p></li><li><p><code>EXPOSE</code>：仅仅是决定<code>容器</code>使用什么端口，不会自动在宿主端口进行端口映射</p></li></ul></li></ul><h3 id="workdir" tabindex="-1">WORKDIR <a class="header-anchor" href="#workdir" aria-hidden="true">#</a></h3><ul><li><p><code>WORKDIR</code>指定工作目录</p></li><li><p>这个指定的<code>目录</code>很重要，会影响很多命令执行时所操作的目录，一定要写对</p></li><li><p><code>WORKDIR</code>为后续的<code>RUN、CMD、ENTRYPOINT</code>指令<code>配置工作目录</code>，以后各层的当前目录就是被指定的目录，如果<code>目录不存在</code>，<code>WORKDIR</code>会帮助我们<code>创建目录</code></p></li></ul><h2 id="build" tabindex="-1">build <a class="header-anchor" href="#build" aria-hidden="true">#</a></h2><ul><li>构建镜像</li></ul><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">OPTIONS</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">PATH</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">URL</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">-</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;"># 例如：</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">docker</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">build</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-t</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">nginx:v1</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">.</span></span>
<span class="line"></span></code></pre></div><p><strong>镜像构建上下文</strong></p><ul><li><p><code>docker build</code>命令末尾会指定一个路径，通常为<code>.</code>，这个<code>.</code>的作用就是来<code>指定上下文路径</code></p></li><li><p><code>docker build</code>这一构建命令的执行，实际上是使用<code>远程调用</code>形式在服务端（Docker 引擎）完成。在服务端构建时，有可能需要将<code>本地的一些文件复制到镜像里面</code>去，服务器要获取本地需要复制的文件就是要通过这个上下文路径，而这个路径是我们自己在<code>build</code>时指定的路径</p></li><li><p><code>docker build</code>命令获取到这个路径之后，会将路径下内容打包，传给<code>Docker引擎</code>，这样<code>Docker引擎</code>收到这个上下文包之后，展开就会得到构建镜像所需文件</p></li><li><p>如果所给出的<code>URL</code>不是个<code>仓库地址</code>，而是个<code>tar压缩包</code>，那么<code>Docker引擎</code>会<code>下载</code>这个包，并<code>自动解压缩</code>，以其作为上下文，开始构建</p></li><li><p>如果标准输入传入的是<code>文本文件</code>，则将其视为<code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取<code>Dockerfile</code>的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件<code>COPY</code>进镜像之类的事情</p></li></ul>`,73),p=[n];function c(t,d,i,r,C,D){return e(),l("div",null,p)}const A=s(o,[["render",c]]);export{u as __pageData,A as default};
