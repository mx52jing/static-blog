---
layout: doc
---

# 连接数据库

## 连接`Mysql`数据库

### 项目初始化

```shell
go mod init gorm-related
```

- 项目目录

```shell
.
├── config
│   └── db.yaml
├── go.mod
├── go.sum
└── main.go
```

- `config/db.yaml`配置

```yaml
mysql:
  db1:
    username: root
    password: study_student
    host: 127.0.0.1
    port: 1000
    dbName: lyb
```

### 下载依赖

```shell
# 连接数据库使用
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
# 读取mysql yaml配置
go get -u github.com/spf13/viper
```

### 连接数据库

- **拆分为下面三步:**

#### 读取`yaml`的`mysql`配置

```Go
type DatabaseConfig struct {
	Username string
	Password string
	Host     string
	Port     int
	DBName   string
}

// 获取数据库配置
func loadDbConfig(configFile string) (*DatabaseConfig, error) {
	viper.SetConfigFile(configFile)
	err := viper.ReadInConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}
	var config DatabaseConfig
	err = viper.UnmarshalKey("mysql.db1", &config)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}
	return &config, nil
}
```

#### 根据配置生成连接url

```Go
// 生产连接数据库链接
func genDbUrl(config *DatabaseConfig) string {
	return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local", config.Username, config.Password, config.Host, config.Port, config.DBName)
}
```

#### 连接数据库

```Go
// 连接数据库
func connectToDb(dbUrl string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dbUrl), &gorm.Config{})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MySQL database: %w", err)
	}
	return db, nil
}
```

- **完整代码**

```Go
package main

import (
	"fmt"
	"log"

	"github.com/spf13/viper"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

type DatabaseConfig struct {
	Username string
	Password string
	Host     string
	Port     int
	DBName   string
}

// 获取数据库配置
func loadDbConfig(configFile string) (*DatabaseConfig, error) {
	viper.SetConfigFile(configFile)
	err := viper.ReadInConfig()
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}
	var config DatabaseConfig
	err = viper.UnmarshalKey("mysql.db1", &config)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}
	return &config, nil
}

// 生产连接数据库链接
func genDbUrl(config *DatabaseConfig) string {
	return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local", config.Username, config.Password, config.Host, config.Port, config.DBName)
}

// 连接数据库
func connectToDb(dbUrl string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dbUrl), &gorm.Config{})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to MySQL database: %w", err)
	}
	return db, nil
}

func main() {
	// 获取数据库配置
	dbConfig, err := loadDbConfig("config/db.yaml")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}
	// 根据数据库配置获取url
	dbUrl := genDbUrl(dbConfig)
	// 根据生产的url连接数据库
	db, connectErr := connectToDb(dbUrl)
	if connectErr != nil {
		log.Fatalf("Failed to connect to MySQL database: %v", connectErr)
	}
	fmt.Println("Successfully connected to MySQL database!", db)
}
```

## 高级配置

### 命名策略配置

`gorm`采用的`命名策略`:

- `表名`是`蛇形复数`

- `字段名`是`蛇形单数`

例如结构体如下:
```Go
type User struct {
	ID       uint
	UserName string 
	Age      int
	Email    string
}
```
通过`gorm`生成的表结构如下

```sql
CREATE TABLE users
(
    id        bigint UNSIGNED AUTO_INCREMENT
        PRIMARY KEY,
    user_name longtext NULL,
    age       bigint   NULL,
    email     longtext NULL
);
```

如上所示:

- 结构体名称`User`生成的表名为`users`
- 字段名称都小写，有`驼峰(UserName)`的字段名称被转换为`蛇形(user_name)`

如果想`自定义表名`，可以通过以下方法

- 实现`TableName`方法，这种方法只会修改当前设置的表

```Go
type User struct {
	ID       uint
	UserName string 
	Age      int   
	Email    string 
}

// TableName 会将 User 的表名重写为 `customUser`
func (User) TableName() string {
	return "customUser"
}
```

- 修改连接数据库时的配置，全局修改，所有表命名规则都会修改

```Go
db, err := gorm.Open(mysql.Open(dbUrl), &gorm.Config{
  NamingStrategy: schema.NamingStrategy{
    // TablePrefix: "lyb_", // 生成的表名前缀，User结构体生成的表名为lyb_users
    // SingularTable: true, // 使用单数表名，设置为true后，User结构体生成的表名为user，而不是users
    // NoLowerCase: true, // 跳过转换蛇形命名
    // NameReplacer: strings.NewReplacer("User", "Cid"), // 名称替换，执行gorm名称替换策略之前，将User替换为Cid  
  },
})
```

### 日志配置

- 日志级别有`Silent`、`Error`、`Warn`、`Info`

- `Gorm`有一个[默认 logger](https://github.com/go-gorm/gorm/blob/master/logger/logger.go)实现，默认情况下，它会打印`慢SQL`和`错误`

- 可以在`初始化`时自定义它，会改变`全局日志规则`

```Go
newLogger := logger.New(
  log.New(os.Stdout, "\r\n", log.LstdFlags), // io writer
  logger.Config{
    SlowThreshold:              time.Second,   // Slow SQL threshold 慢sql阀值
    LogLevel:                   logger.Info, // Log level 日志级别
    IgnoreRecordNotFoundError: true,           // Ignore ErrRecordNotFound error for logger 忽略ErrRecordNotFound（记录未找到）错误
    ParameterizedQueries:      true,           // Don't include params in the SQL log 不要在 SQL 日志中包含参数
    Colorful:                  false,          // Disable color 关闭颜色
  },
)
db, err := gorm.Open(mysql.Open(dbUrl), &gorm.Config{
  Logger: newLogger
})
```

- 修改一个连续会话日志

```Go
// Continuous session mode
tx := db.Session(&Session{Logger: newLogger})
tx.First(&user)
tx.Model(&user).Update("Age", 18)
```

- `Debug`单个操作，将`当前操作`的`log`级别调整为`logger.Info`

```Go
DB.Debug().AutoMigrate(&User{})
```

`Debug`方法原理如下

```Go
// Debug start debug mode
func (db *DB) Debug() (tx *DB) {
	tx = db.getInstance()
	return tx.Session(&Session{
		Logger: db.Logger.LogMode(logger.Info),
	})
}
```








