---
layout: doc
---

# 初体验

## Introduction

- `Vite`是一个`开箱即用(out of box)`的`构建工具`，不需要使用额外配置就可以帮助我们处理构建工作。

- `Vite`在`开发阶段`基于`浏览器原生ESM`的支持实现了`no-bundle`服务，并且开发环境使用`Esbuild`打包，提高构建速度

## 创建项目并启动

创建一个空项目`initial_experience`，使用`pnpm init`初始化项目，然后下载`Vite`

```shell
mkdir initial_experience
cd initial_experience
pnpm init
pnpm install vite
```

- 目录结构

```shell
initial_experience
├── index.html
├── package.json
├── pnpm-lock.yaml
└── src
    ├── count.js
    └── main.js
```

- `index.html`

```html
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>initial experience</title>
</head>
<body>
<div>initial experience</div>
<script src="./src/main.js" type="module"></script>
</body>
</html>
```

- `main.js`

```javascript
import { num } from "./count";

console.log('main.js', num)
```

- `count.js`

```javascript
export const num = 100;
```

- 在`package.json`中添加命令

```json
"scripts": {
  "dev": "vite",
  "build": "vite build",
  "test": "echo \"Error: no test specified\" && exit 1"
},
```

- 启动项目

```shell
pnpm dev --host
```

- 启动后可以在控制台看到打印出`main.js 100`

:::tip
- `index.html`需要在项目根目录中

- 在`index.html`中，要声明一个`type="module"`的`script`标签
:::

## 引入第三方模块

```shell
pnpm install lodash-es
```

- `main.js`

```javascript
import { num } from "./count.js"

console.log('main.js', num)
```

- `count.js`

```javascript
import _ from 'lodash-es'
export const num = 100

console.log('count.js')
```

- 先中止运行的本地服务，直接双击`index.html`，在浏览器中打开

- 如果先去除掉`lodash-es`的引入，控制台是会正常打印，如下

```javascript
count.js
main.js 100
```

- 如果放开`lodash-es`的引入，然后刷新页面，发现报错如下:

```javascript
Uncaught TypeError: Failed to resolve module specifier "lodash-es". 
Relative references must start with either "/", "./", or "../".
```

- 可以看到，浏览器原生`esmodule`只支持`/`, `./,` 或者`../`开头的路径

- 此时运行`pnpm dev --host`重新启动`Vite`开发服务

- 可以在`count.js`中看到引入的`lodash-es`路径被替换了，这是因为`Vite`具有`依赖预构建`功能


![](/image/Vite/1.png)

## 依赖预构建

- 默认情况下，`esmodule`规范下导入模块的时候，要么是`绝对路径`,要么是`相对路径`，遇到其他类型的路径不会去解析，所以`esmodule`在处理导入非`绝对/相对`路径的时候，不会去搜寻`node_modules`，而`vite`会去处理这个情况

- `vite`遇到非`绝对/相对`路径的时候，会去进行路径补全，例如：

```js
// 补全前
import _ from 'lodash-es';
// 补全之后
import _ from "/node_modules/.vite/deps/lodash-es.js?v=a2b41ab7"
```

- 当`vite`遇到`非esmodule`模块的语法，例如`commonjs`语法，`vite`会先找到其对应的依赖，然后调用`esbuild`将其转换为`esmodule`规范，然后放到当前项目的`node_modules/.vite/deps`目录下，同时对`esmodule`规范的各个模块进行统一集成，会将文件中的`import`引入都集成到引入的文件中

例如：
- `index.js`
```js
import { a } from './a.js'
import { b } from './a.js'
console.log(a, b)
```
- `a.js`

```js
export const a = 'a模块变量'
```

- `b.js`

```js
export const b = 'b模块变量'
```

集成后的`index.js`
```js
const a = 'a模块变量'
const b = 'b模块变量'
console.log(a, b)
```

:::tip
如果是原生`esmodule`来处理，会产生`3个http请求`

1. 请求`index.js`
2. 发现`index.js`通过`import`导入了`a.js`模块，会创建`http请求`，请求`a.js`
3. 发现`index.js`通过`import`导入了`b.js`模块，会创建`http请求`，请求`b.js`

- 如果依赖的模块过多，会发送`多个http请求`，所以原生的`esmodule`不会帮我们处理`非绝对路径/非相对路径`的引入
:::

### **依赖预构建**解决的问题

- 不同第三方包可能不同导入导出方式，`依赖预构建`会统一处理转换成`esmodule`的形式 

- 对路径处理后直接从`.vite/deps`引入，统一所有资源的路径，方便`路径重写`
- 解决`网络多包传输`问题


### 关闭依赖预购建

- 如果不想让`vite`进行依赖预购建，可以通过配置实现

`vite.config.js`
```js
/** @type {import('vite').UserConfig} */

export default {
  optimizeDeps: {
    exclude: ['lodash-es'] // 指定数组中的依赖不进行构建
  }
}
```

- 以`lodash-es`为例，当去除依赖预构建后，`vite`会把所有的`esmodule`模块都通过`创建http请求`的方式引入，会发送巨量请求

![](/image/Vite/3.png)

- 从上图可以看到，关闭`依赖预构建`后，浏览器发送了大量请求去加载`lodash-es`的方法模块，这将造成巨大的网络开销


### `vite.config.js`语法提示

- 我们想要在`vite.config.js`中写配置的时候有相应的`API`提示，可通过以下两种方法

1. 使用`vite`自带的`defineConfig`方法

```js
import { defineConfig } from "vite";

export default defineConfig({
  optimizeDeps: {
    exclude: ['lodash-es'] // 指定数组中的依赖不进行构建
  }
})
```
2. 引入类型标注

```javascript
/**
 * @type {import('vite').UserConfig}
 */

const config = {
    optimizeDeps: {
        exclude: ['lodash-es']
    }
}

export default config
```

- 效果如下

![](/image/Vite/2.png)

## `vite.config.js`中为什么可以用`esmodule`语法

- `vite`读取`vite.config.js`的时候，会先解析语法，如果是`esmodule`语法，会先转换成`commonjs`语法
