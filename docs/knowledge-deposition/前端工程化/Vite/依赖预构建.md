---
layout: doc
---

# 依赖预构建


- 默认情况下，`esmodule`规范下导入模块的时候，要么是`绝对路径`,要么是`相对路径`，遇到其他类型的路径不会去解析，所以`esmodule`在处理导入非`绝对/相对`路径的时候，不会去搜寻`node_modules`，而`vite`会去处理这个情况

- `vite`遇到非`绝对/相对`路径的时候，会去进行路径补全，例如：

```js
// 补全前
import _ from 'lodash-es';
// 补全之后
import _ from "/node_modules/.vite/deps/lodash-es.js?v=a2b41ab7"
```

- 当`vite`遇到`非esmodule`模块的语法，例如`commonjs`语法，`vite`会先找到其对应的依赖，然后调用`esbuild`将其转换为`esmodule`规范，然后放到当前项目的`node_modules/.vite/deps`目录下，同时对`esmodule`规范的各个模块进行统一集成，会将文件中的`import`引入都集成到引入的文件中

例如：
- `index.js`
```js
import { a } from './a.js'
import { b } from './a.js'
console.log(a, b)
```
- `a.js`

```js
export const a = 'a模块变量'
```

- `b.js`

```js
export const b = 'b模块变量'
```

集成后的`index.js`
```js
const a = 'a模块变量'
const b = 'b模块变量'
console.log(a, b)
```

:::tip
如果是原生`esmodule`来处理，会产生`3个http请求`

1. 请求`index.js`
2. 发现`index.js`通过`import`导入了`a.js`模块，会创建`http请求`，请求`a.js`
3. 发现`index.js`通过`import`导入了`b.js`模块，会创建`http请求`，请求`b.js`

- 如果依赖的模块过多，会发送`多个http请求`，所以原生的`esmodule`不会帮我们处理`非绝对路径/非相对路径`的引入
:::

### **依赖预构建**解决的问题

- 不同第三方包可能不同导入导出方式，`依赖预构建`会统一处理转换成`esmodule`的形式 

- 对路径处理后直接从`.vite/deps`引入，统一所有资源的路径，方便`路径重写`
- 解决`网络多包传输`问题


### 关闭依赖预购建

- 如果不想让`vite`进行依赖预购建，可以通过配置实现

`vite.config.js`
```js
/** @type {import('vite').UserConfig} */

export default {
  optimizeDeps: {
    exclude: ['lodash-es'] // 指定数组中的依赖不进行构建
  }
}
```

- 以`lodash-es`为例，当去除依赖预构建后，`vite`会把所有的`esmodule`模块都通过`创建http请求`的方式引入，会发送巨量请求

![](/image/Vite/3.png)

- 从上图可以看到，关闭`依赖预构建`后，浏览器发送了大量请求去加载`lodash-es`的方法模块，这将造成巨大的网络开销
